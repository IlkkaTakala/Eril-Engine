2;0;
###VERTEX###
#version 430 core
layout (location = 0) in vec3 in_position;
layout (location = 1) in vec2 in_texCoord;

out vec2 TexCoords;

void main()
{
	TexCoords = in_texCoord;
	gl_Position = vec4(in_position, 1.0);
}
###END_VERTEX###
###FRAGMENT###
#version 430 core

out float FragColor;
  
in vec2 TexCoords;

layout (std140, binding = 0) uniform Globals
{
    mat4 projection;
    mat4 view;
	vec4 viewPos;
	ivec2 screenSize;
	int sceneLightCount;
};

struct PointLight {
	vec4 color;
	vec4 positionAndSize;
	vec4 Rotation;
	ivec4 type;
	mat4 transforms[6];
};

struct VisibleIndex {
	int index;
};

layout(std430, binding = 1) readonly buffer LightBuffer {
	PointLight data[];
} lightBuffer;

layout(std430, binding = 2) readonly buffer VisibleLightIndicesBuffer {
	VisibleIndex data[];
} visibleLightIndicesBuffer;

uniform sampler2D Position;
uniform int numberOfTilesX;

void main() {
	ivec2 location = ivec2(gl_FragCoord.xy);
	ivec2 tileID = location / ivec2(16, 16);
	uint index = tileID.y * numberOfTilesX + tileID.x;
	uint offset = index * 1024;
	
	float attenuation = 1.0;
	vec3 FragPos = texture(Position, TexCoords).xyz;
	
	uint i;
	for (i = 0; i < 1024 && visibleLightIndicesBuffer.data[offset + i].index != -1; i++) {
		uint lightIndex = visibleLightIndicesBuffer.data[offset + i].index;
		PointLight light = lightBuffer.data[lightIndex];
		
		if (light.type.x == 1) {
			float distance 	= length(light.positionAndSize.xyz - FragPos);
			float radius 	= light.positionAndSize.w * 10.0;
			float b 		= 1.0 / (radius * radius * 0.1);
			attenuation 	*= 1.0 / (1.0 + 0.1 * distance + b * distance * distance);
		}
	}
	
    FragColor = (1.0 - attenuation * (1.0 - attenuation) * 2.0) * 0.5;
}
###END_FRAGMENT###